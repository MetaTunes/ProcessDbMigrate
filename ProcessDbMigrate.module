<?php namespace ProcessWire;

/**
 * ProcessWire DbMigrate
 * by Mark Evens
 * with tips and snippets from Adrian Jones and Bernhard Baumrock
 *
 * Class ProcessDbMigrate
 * @package ProcessWire
 *
 * @property object $migrations The parent page for migration pages
 * @property object $migrationTemplate The template for migration pages
 * @property object $migrationsTemplate The template for the parent page
 * @property string $migrationsPath Path to the folder holding the migrations .json files
 * @property string $modulePath Path to this module
 * @property string $bootstrapPath Path to the folder holding the original bootstrap data (it is copied to migrationsPath on installation)
 * @property DbMigrationPage $bootstrap
 * @property string $adminPath Path to the admin root (page id = 2)
 * @property string $runtimePath
 *
 */

class ProcessDbMigrate extends Process implements Module, ConfigurableModule
{

    public static function getModuleinfo() {
        return [
            'permanent' => false, 		// true if module is permanent and thus not uninstallable (3rd party modules should specify 'false')
            'title' => 'ProcessDbMigrate',
            'summary' => 'Maintain migration data',
            'comments' => '',
            'author' => 'Mark Evens',
            'version' => "0.0.13",
            'autoload' => true,
            'singular' => true,
            'page' => array( 			// optionally install/uninstall a page for this process automatically
                'name' => 'dbmigrations', 	// name of page to create
                'parent' => 'setup', 	// parent name (under admin) or omit or blank to assume admin root
                'title' => 'Database Migrations', 	// title of page, or omit to use the title already specified above
            ),
            'icon' => 'upload',
            'requires' => ['ProcessWire>=3.0.148','FieldtypeRuntimeOnly'],
            'installs' => [],
            'permission' => 'admin-dbMigrate',         // ToDo tighten permissions?
        ];
    }


    const MIGRATION_TEMPLATE = 'DbMigration';
    const MIGRATION_PARENT_TEMPLATE = 'DbMigrations';
    const MIGRATION_PARENT = 'dbmigrations/';
    const MIGRATION_PATH = 'DbMigrate/migrations/';
    const MODULE_PATH = 'ProcessDbMigrate/';
    const BOOTSTRAP_PATH = 'ProcessDbMigrate/bootstrap';
    const RUNTIME_PATH = 'ProcessDbMigrate/RuntimeOnly';


    public function __construct() {

    }

    /*
     * API available here
     */
    public function init() {
        require_once('DbMigrationPage.class.php');
        // Set properties
        $this->set('adminPath',  wire('pages')->get(2)->path);
        $this->set('migrations', wire('pages')->get($this->adminPath . self::MIGRATION_PARENT));
        $this->set('migrationTemplate', wire('templates')->get(self::MIGRATION_TEMPLATE));
        $this->set('migrationsTemplate', wire('templates')->get(self::MIGRATION_PARENT_TEMPLATE));
        $this->set('migrationsPath', wire('config')->paths->templates . self::MIGRATION_PATH);
        $this->set('modulePath', wire('config')->paths->siteModules . self::MODULE_PATH);
        $this->set('bootstrapPath', wire('config')->paths->siteModules . self::BOOTSTRAP_PATH);
        $this->set('bootstrap', wire()->pages->get("parent=$this->migrations, template=$this->migrationTemplate, name=bootstrap"));
        $this->set('runtimePath', wire('config')->paths->siteModules . self::RUNTIME_PATH);
        // Need custom uninstall to uninstall bootstrap before uninstalling the module
        $this->addHookBefore("Modules::uninstall", $this, "customUninstall");
        // trigger init in Page class as it is not auto
        if (class_exists('DbMigrationPage')) {
            $p = new DbMigrationPage();
            $p->init();
        }
        //bd('INIT DONE');
    }


    /*
     * API and page available here
     */
public function ready() {
// trigger ready() in the Page Class
    // Not sure this one works
//    if (class_exists('DbMigrationPage')) {
//        $p = new DbMigrationPage();
//        $p->ready();
//    }
    // alternative - to trigger all page classes
    if ($this->database_name and $this->show_name) {
        $this->wire()->message('DATABASE NAME = ' . $this->database_name);
    }
    $page = $this->wire()->page;
    if ($page and $page->template == 'admin') {
        $pId = $this->wire()->input->get->int('id');
        $p = $this->wire('pages')->get($pId);
    }
    if (isset($p) and $p and $p->id and method_exists($p, 'ready')) $p->ready();
    $this->wire()->config->scripts->add($this->wire()->urls->siteModules . 'ProcessDbMigrate/ProcessDbMigrate.js');
    $this->wire->config->js('ProcessDbMigrate', [
        'confirmDelete' => $this->_('Please confirm that this migration is not used in any other database before deleting it.
If it has been used in another environment and is no longer wanted then you will need to remove any orphan json files there manually.')
    ]);

}



    public function ___install($upgrade=false) {
        //bd('install');
        $this->init();  // Need the properties to be loaded for the bootstrap, but init() is not called before install()

            // No migrations parent page or templates, or bootstrap has changed
            $this->bootstrap($upgrade);
            $this->init();  // re-initialise now everything should be there
            if (!$this->migrations or !$this->migrations->id) {
                $this->wire->session->error($this->_('Bootstrap failed'));
                return;
            }

        if (!$upgrade) {
            // Create the admin page
            $p = new Page();
            $p->template = 'admin';
            $p->name = self::getModuleinfo()['page']['name'];
            $p->parent = $this->adminPath . self::getModuleinfo()['page']['parent'] . '/';
            $p->title = self::getModuleinfo()['page']['title'];
            $p->process = str_replace(__NAMESPACE__ . '\\', '', get_class());
            $p->save();
        }
    }


    /**
     * Install the bootstrap page
     * @throws WireException
     * @param boolean $upgrade  True for upgrade only.
     * @throws WirePermissionException
     */
    protected function bootstrap($upgrade=false) {
        // copy the bootstrap files to templates
        //bd($this->migrationsPath, '$this->migrationsPath');
        if (!is_dir($this->migrationsPath . 'bootstrap/')) if (!wireMkdir($this->migrationsPath . 'bootstrap/', true)) {
            throw new WireException($this->_('Unable to create migration directory') . ": {$this->migrationsPath}bootstrap/");
        }
        $this->wire()->files->copy($this->bootstrapPath, $this->migrationsPath . 'bootstrap/');
        // also copy the RuntimeOnly files to templates
        if (!is_dir($this->wire('config')->paths->templates . 'RuntimeOnly/')) if (!wireMkdir($this->wire('config')->paths->templates . 'RuntimeOnly/', true)) {
            throw new WireException($this->_('Unable to create RuntimeOnly directory') . ": {$this->wire('config')->paths->templates}RuntimeOnly/"); // RuntimeOnly is a name
        }
        $this->wire()->files->copy($this->runtimePath, $this->wire('config')->paths->templates . 'RuntimeOnly/');

        // Before we are able to use the copied .json files, we need to check and amend the admin root in use as it may differ in the target system
        if ($this->adminPath != '/processwire/') {
            $jsonFiles = ['/new/data.json', '/new/migration.json', '/old/data.json', '/old/migration.json'];
            foreach ($jsonFiles as $jsonFile) {
                $json = (file_exists($this->migrationsPath . 'bootstrap'. $jsonFile)) ? file_get_contents($this->migrationsPath . 'bootstrap' . $jsonFile) : null;
                if ($json) {
                    $json = str_replace('/processwire/', $this->adminPath, $json);
                    file_put_contents($this->migrationsPath . 'bootstrap'. $jsonFile, $json);
                }
            }
        }
        if (!$upgrade) {
            // Now run the bootstrap using the copied/amended files
            $className = 'ProcessWire\\' . self::MIGRATION_TEMPLATE . 'Page';
            $dummyBootstrap = new $className();  // dummy migration
            // NB we cannot assign a template to dummy-bootstrap as we need to run it to create the template!!
            $dummyBootstrap->name = 'dummy-bootstrap';
            $dummyBootstrap->installMigration('new');
        }

    }

    public function ___upgrade($fromVersion, $toVersion) {
        $this->___install(true);
    }

    /**
     * Custom uninstall routine
     *
     * @param HookEvent $event
     */
    public function customUninstall($event) {
        $class = $event->arguments(0);
        if(__NAMESPACE__ . '\\' . $class != __CLASS__) return;
        //bd('IN CUSTOM UNINSTALL - uninstalling....');
        $abort = false;

        // check 1
        $setupPage = $this->wire()->pages->get($this->adminPath . 'setup/dbmigrations/');
        if ($setupPage and $setupPage->id) {
            if (!$this->bootstrap or !$this->bootstrap->id) {
                $this->error($this_('Uninstall of bootstrap failed.') . "\n" .
                    $this->_('No bootstrap page  - try going to setup page and refreshing before uninstalling'));
                $abort = true;
            }
        } else {
            //bd('NO SETUP PAGE');
            $event->return;
            return;
        }
        // unset system flags on templates
        $t = $this->wire('templates')->get(self::MIGRATION_TEMPLATE);
        $t->flags = Template::flagSystemOverride;
        $t->flags = 0;
        foreach ($t->fieldgroup as $f) {
            $f->flags = Field::flagSystemOverride;
            $f->flags = 0;
        }
        $t = $this->wire('templates')->get(self::MIGRATION_PARENT_TEMPLATE);
        $t->flags = Template::flagSystemOverride;
        $t->flags = 0;
        // check2
        if (!$abort) {
            $this->bootstrap->ready();  // Need the properties to be loaded for the uninstall, but ready() is not called before uninstall()
            try {
                //bd('uninstalling bootstrap');
                $this->bootstrap->installMigration('old');
            } catch (WireException $e) {
                //bd($e, 'WireException');
                $msg = $e->getMessage();
                $this->error($this->_('Uninstall of bootstrap failed or incomplete.') . "\n $msg. \n" . $this->_('Re-install the module and fix the cause of the problem before uninstalling again.'));
                $abort = false; //allow uninstall to complete as re-installation of bootstrap may be required to enable proper uninstallation
            }
        }

        // uninstall?
        if($abort) {
            //bd('ABORTING UNINSTALL');
            // there were some non-critical errors
            // close without uninstalling module -
            $event->replace = true; // prevents original uninstall
            $this->session->redirect("./edit?name=$class"); // prevent "module uninstalled" message
        }
    }

    /**
     * Remove unused fields or templates
     * @return void
     */
    public function cleanup() {
    // Not currently used
    }


    /**
     * Main admin page - list migrations & allows creation of new migration
     * @return array|string
     * @throws WireException
     * @throws WirePermissionException
     */
    public function ___execute() {
        $pageEdit = $this->wire('urls')->admin . 'page/edit/?id=';
        $currentUser = wire('user'); // For future usage? Currently access is just via permissions
        $table = $this->wire('modules')->get("MarkupAdminDataTable");
        $table->headerRow(['Name', 'Type', 'Status', 'Title', 'Summary', 'Items', 'Created']);
        $table->setSortable(true);
        $table->setEncodeEntities(false);
//        $migrations = $this->wire('pages')->get('/dbmigrations/');
        $this->moduleRefresh();
//        /* @var $migrations DbMigrationsPage */
        $migrationPages = $this->migrations->find("template=$this->migrationTemplate, sort=-created, include=all");
        foreach ($migrationPages as $migrationPage) {
            /* @var $migrationPage DbMigrationPage */
            if (!$migrationPage->meta('locked')) {
                $installedStatus = $migrationPage->exportData('compare');
                $status = $installedStatus['status'];
                if ($migrationPage->meta('installable')) {
                    $statusColour = ($status == 'installed') ? 'lightgreen' : (($status == 'uninstalled') ? 'salmon' : 'orange');
                } else {
                    $statusColour = ($status == 'exported') ? 'lightgreen' : 'salmon';
                }
            } else {
                $status = 'Locked';
                $statusColour = 'LightGrey';
            }
            //bd($migrationPage, $status);
            //bd($installedStatus);
            $lockIcon = ($migrationPage->meta('locked')) ? '<i class="fa fa-lock"></i>' : '<i class="fa fa-unlock"></i>';
            $itemList = [];
            foreach ($migrationPage->dbMigrateItem as $migrateItem) {
                /* @var $migrateItem RepeaterDbMigrateItemPage */
                $oldName = ($migrateItem->dbMigrateOldName) ? '|' . $migrateItem->dbMigrateOldName : '';
                $itemList[] = '<em>' . $migrateItem->dbMigrateAction->title . ' ' . $migrateItem->dbMigrateType->title . '</em>: ' . $migrateItem->dbMigrateName . $oldName;
            }
            $itemsString = implode("    ", $itemList);
            $data = array(
                // Values with a string key are converter to a link: title => link
                $migrationPage->name => $pageEdit . $migrationPage->id,
                ($migrationPage->meta('installable')) ? '<span class="fa fa-arrow-down"></span>' : '<span class="fa fa-arrow-up"></span>',
                $lockIcon . ' <span style="background:' . $statusColour . '">' . $status . '</span>',
                $migrationPage->title,
                $migrationPage->dbMigrateSummary,
                $itemsString,
                date('Y-m-d', $migrationPage->created),
            );
            $table->row($data);

        }
        $this->wire('modules')->get('JqueryUI')->use('modal');
        $out = '<div><h3>' . $this->_('Existing migrations are listed below. Go to the specific migration page for any actions.') . '</h3><p>' .
            $this->_('Exportable migrations') . ' - <span class="fa fa-arrow-up"></span> - ' . $this->_('originated in this database, can be edited here and are a source of a migration to be installed elsewhere.') . '</p><p>' .
            $this->_('Installable migrations') . ' - <span class="fa fa-arrow-down"></span> - ' .
            $this->_('originated from another database and can be installed/uninstalled here (except that "bootstrap" cannot be uninstalled). They cannot be changed except in the original database.') . '</p><p>' .
            $this->_('Locked migrations') . ' - <span class="fa fa-lock"></span> - ' . $this->_('can no longer be changed or actioned.') . '</p></div><div>';
        $out .= $table->render();
            $btnAddNew = $this->createNewButton($this->migrationTemplate, $this->migrations); //createNewButton also allows title and values to be set, but not used here
            $out .= $btnAddNew->render();
            $btn = $this->wire('modules')->get("InputfieldButton");
            $btn->attr('href', './get-migrations/');
            $btn->attr('id', "get_migrations");
            $btn->attr('value', "Refresh");
            $btn->showInHeader();
            $out .= $btn->render();
        return $out;
    }


    /**
     * @param $tpl
     * @param $page
     * @param null $title
     * @param array $values
     * @return array|array[]|\array[][]|bool|float|int|int[]|mixed|null[]|\null[][]|object|_Module|Field|Fieldtype|Module|NullPage|Page|PageArray|Pages|Permission|Role|SessionCSRF|Template|User|Wire|WireArray|WireData|WireDataDB|WireInputData|string|string[]|\string[][]|null
     * @throws WireException
     * @throws WirePermissionException
     */
    public function createNewButton($tpl, $page, $title=null, $values=[]) {
        $template = wire()->templates->get($tpl);
        $valuesStr = urlencode(serialize($values));
        $titleStr = urlencode($title);
        $btnAddNew = wire('modules')->get("InputfieldButton");
        $btnAddNew->attr('href', "./new-page/?template=" . $template->name . "&parent=" . $page->id . "&title=" . $titleStr . "&values=" . $valuesStr);
        $btnAddNew->attr('id', "AddPage_" . $template);
        $btnAddNew->attr('value', "Add New " . $template);
        $btnAddNew->showInHeader();
        return $btnAddNew;
    }


    /**
     * @throws WireException
     */
    public function ___executeNewPage() {
        $templateName = $this->wire()->input->get->text("template");
        $template = wire()->templates->get($templateName);  //name
        $parent = $this->wire()->input->get->int("parent");  //id
//        $parentPage = wire()->pages->get("id=$parent");
        $title = urldecode($this->wire()->input->get->text('title'));  //string
        $values = unserialize(urldecode($this->wire()->input->get->text('values'))); //array
        $className = $template . 'Page';
        $url = './';
        if (!$title) {
            $url = wire('config')->urls->admin . "page/add/?parent_id=" . $parent . "&template_id=" . $template->id;
        } else {
            $newPage = new $className();
            $newPage->of(false);
            $newPage->title = $title;
            $newPage->save();
            $newPage->setAndSave($values);
        }
        return wire()->session->redirect($url);
    }

    /**
     * Refresh all migration pages - called by executeGetMigrations
     * @throws WireException
     * @throws WirePermissionException
     */
    public function moduleRefresh() {
        //bd('in module refresh');
        $migrationPath = $this->migrationsPath;
        $migrationFiles = $this->wire('files')->find($migrationPath);
        $migrationFiles = array_filter($migrationFiles, function($e) {
            return (basename($e, '.json') == 'migration' and basename(pathinfo($e)['dirname']) == 'new');
        });
        //bd($migrationFiles, 'migration files');
//        $migrations = $this->wire('pages')->get('/dbmigrations/');

        if (!$this->migrations or !$this->migrations->id or !$this->wire()->templates->get('DbMigrations') or !$this->wire()->templates->get('DbMigration')) {
            $this->wire()->session->error('No DbMigrations page');
            $this->wire()->session->redirect('../');
            return;
        }
        $migrationPages = $this->migrations->find("template=$this->migrationTemplate, sort=-modified, include=all");
        $alreadyFound = [];
        foreach ($migrationPages as $migrationPage) {
            /* @var $migrationPage DbMigrationPage */
            $migrationDirectory = $migrationPath . $migrationPage->name . '/new/';
            $foundFiles = $this->wire('files')->find($migrationDirectory);
            foreach ($foundFiles as $foundFile) {
                if (basename($foundFile, '.json') == 'migration') $alreadyFound[$migrationPage->name] = $foundFile;
            }
        }
        $wantedFiles = array_diff($migrationFiles, array_values($alreadyFound));
        //bd($alreadyFound, '$alreadyFound');
        //bd($wantedFiles, 'wanted files');
        foreach ($wantedFiles as $file) {
            //Retrieve the data from our text file.
            $fileContents = wireDecodeJSON(file_get_contents($file));
            //bd($fileContents, 'wanted file contents');
            if (isset($fileContents['sourceDb'])) unset($fileContents['sourceDb']);
            foreach ($fileContents as $content) {
                // There should only be one item - Todo: check this
                foreach ($content as $line) {
                    foreach ($line as $pathName => $values) {
                        $pageName = $values['name'];
                        $className = 'ProcessWire\\' . self::MIGRATION_TEMPLATE . 'Page';
                        $newMigration = new $className();
                        $newMigration->of(false);
                        $newMigration->name = $pageName;
                        $newMigration->parent = $this->migrations;
                        $newMigration->status = 1;
                        //bd($values, 'in module refresh with $values');
                        $newMigration->save();
                        unset($values['id']);
                        unset($values['parent']);
                        unset($values['template']);
                        unset($values['status']);
                        // split out repeaters from values
                        $r = $newMigration->getRepeaters($values);
                        $repeaters = $r['repeaters'];
                        $values = $r['values'];  // values has repeaters removed
                        //
                        //bd($values, 'wanted values');
                        //bd($newMigration, 'newMigration');
                        $newMigration->setAndSave($values);
                        $newMigration->setAndSaveRepeaters($repeaters);
                    }
                }
            }
            // To prevent re-saving, show 'Install' and 'Uninstall' buttons and remove 'Export Data' button - implicitly by setting meta('installable'):
            if (isset($newMigration) and $newMigration and $newMigration->id) $newMigration->meta('installable', true);
        }
        foreach ($alreadyFound as $pName => $found) {
            $migrationPage = $this->migrations->get("name=$pName");
            if ($migrationPage and $migrationPage->id) {
                $migrationPage->ready(); // Need to trigger it as not auto
                $migrationPage->refresh($found);
            }
        }
    }


    /**
     * Execute method for refresh Linked by Refresh button on this page
     * @throws WireException
     * @throws WirePermissionException
     */
    public function ___executeGetMigrations() {
        $this->moduleRefresh();
        $this->wire()->session->redirect('../');
    }

    /**
     * Execute method for export - linked by button in runtime_markup_migrationActions
     * @throws WireException
     */
    public function ___executeExportData() {
        $pageId = $this->wire()->input->get->int('id');
        $migrationPage = $this->wire()->pages->get($pageId);
        /* @var $migrationPage DbMigrationPage */
        $migrationPage->exportData('new');
        $this->wire()->session->redirect($this->wire()->urls->admin . 'page/edit/?id=' . $pageId);
    }

    /**
     * Execute method for removing files - linked by button in runtime_markup_migrationActions
     * @throws WireException
     */
    public function ___executeRemoveFiles() {
        $pageId = $this->wire()->input->get->int('id');
        $migrationPage = $this->wire()->pages->get($pageId);
        /* @var $migrationPage DbMigrationPage */
        $migrationPath = $this->migrationsPath . $migrationPage->name . '/';
        if (is_dir($migrationPath)) {
            $this->wire()->files->rmdir($migrationPath, true);
        }
        $this->wire()->session->redirect($this->wire()->urls->admin . 'page/edit/?id=' . $pageId);
    }


    /**
     * Execute method for install - linked by button in runtime_markup_migrationActions
     * @throws WireException
     * @throws WirePermissionException
     */
    public function ___executeInstallMigration() {
        $pageId = $this->wire()->input->get->int('id');
        $migrationPage = $this->wire()->pages->get($pageId);
        /* @var $migrationPage DbMigrationPage */
        $migrationPage->installMigration('new');
        $this->wire()->session->redirect($this->wire()->urls->admin . 'page/edit/?id=' . $pageId);
    }


    /**
     * Execute method for uninstall - linked by button in runtime_markup_migrationActions
     * @throws WireException
     * @throws WirePermissionException
     */
    public function ___executeUninstallMigration() {
        $pageId = $this->wire()->input->get->int('id');
        $migrationPage = $this->wire()->pages->get($pageId);
        /* @var $migrationPage DbMigrationPage */
        $migrationPage->installMigration('old');
        $this->wire()->session->redirect($this->wire()->urls->admin . 'page/edit/?id=' . $pageId);
    }

//    /**
//     * @param $migrationPage
//     * @param $values
//     * @param $newOld
//     * @return array
//     * @throws WireException
//     */
//    protected function replaceImageSource($migrationPage, $values, $newOld) {
//        // $value should be a 2-element array [current, proposed]
//        /* @var $migrationPage DbMigrationPage */
//        $newValues = [];
//        foreach ($values as $value) {
//            if (is_string($value) and $value != strip_tags($value)) {   // $value is html
//                $newValues[] = $migrationPage->replaceImgSrcPath($value, $newOld);
//            } else {
//                $newValues[] = $value;
//            }
//        }
//        return $newValues;
//    }

    /**
     * Markup for the Preview modal
     * @param $value
     * @param int $deep
     * @param $newOld
     * @param $key
     * @param $migrationPage
     * @return string
     */
    protected function formatCompare($migrationPage, $value, $key, $newOld, $deep = 0) {
        if (!$value) return '';
        /* @var $migrationPage DbMigrationPage */
        //bd($value, 'value in formatCompare');

//        if (!is_array($value)) return '<td>' . $value . '</td><td>' . 'Unpaired item' . '</td>';
        if ($this->array_depth($value) == 1) {
            // at the bottom, there should be an unassociated array of length exactly = 2
            if (count($value) != 2)  return '<td style="word-wrap: break-word">' . wireEncodeJSON($value) . '</td><td>' . 'Item is not a pair' . '</td>';
            foreach ($newOld as $col => $type) {
                if ($type != 'current' and strpos($key, 'pages') === 0 and $value[$col] != strip_tags($value[$col])) {
                    $value[$col] = $migrationPage->replaceImgSrcPath($value[$col], $type);
                }
            }
            return '<td style="word-wrap: break-word">' . $value[0] . '</td><td style="word-wrap: break-word">' . $value[1] . '</td>';
        }
//        if ($this->array_depth($value) >= 2) {
            //bd($value, 'depth >= 2 value');
            if (count($value) == 2) {
                // check that one item is not a string, so we don't iterate further in  that case
                $a0 = array_slice($value, 0, 1, true);
                $a1 = array_slice($value, 1, 1, true);
                $v[0] = reset($a0);
                $v[1] = reset($a1);
                if (is_string($v[0]) or is_string($v[1])) {
                    //bd($value, 'depth 2 count 2 value where one element is a string');
                    foreach ($newOld as $col => $type) {
                        $v[$col] = (is_array($v[$col])) ? wireEncodeJSON($v[$col], true, true) : $v[$col];
                        if (strpos($key, 'pages') === 0 and is_string($v[$col]) and $v[$col] != strip_tags($v[$col])) {
                            // NB In this case $v[$col] is json so we need to fix quotes in img src
                            if ($type != 'current') {
                                $v[$col] = $migrationPage->replaceImgSrcPath($v[$col], $type, true);
                            } else {
                                $v[$col] = str_replace('\"', "'", $v[$col]);
                            }
                        }
                    }
                    return '<td style="word-wrap: break-word">' . $v[0] . '</td><td style="word-wrap: break-word">' . $v[1] . '</td>';
                }
            }
//        }
        $out = '';
        $deep += 1;
        foreach ($value as $k => $v) {
            $out .= '</tr><tr><td>' . str_repeat('>&nbsp;', $deep) . $k . '</td>';
            if (is_array($v)) {
                $out .= $this->formatCompare($migrationPage, $v, $key, $newOld, $deep);
            }
            //bd($out, 'out for ' . $k);
        }
        return $out;
    }

    /**
     * Lock the migration linked by runtime_markup_migrationControl
     * @throws WireException
     */
    public function ___executeLock() {
        $pageId = $this->wire()->input->get->int('id');
        $action = $this->wire()->input->get->text('action');
        $migrationPage = $this->wire()->pages->get($pageId);
        $migrationFolder = $this->migrationsPath . $migrationPage->name . '/';
        $now = $this->wire()->datetime->date('Ymd-His');
        if ($action == 'lock') {
            //bd($migrationPage->meta('locked'), 'Meta locked');
            if (is_dir($migrationFolder)) {
                if (!$migrationPage->meta('installable')) {
                    $this->wire()->files->filePutContents($migrationFolder . 'lockfile.txt', $now);
                    $migrationPage->meta('locked', true);
                }
            } else {
                $this->wire()->notices->error(sprintf($this->_("Unable to lock migration as no directory named %s exists."), $migrationPage));
            }
        } else {   // 'unlock'
            $migrationFiles = $this->wire()->files->find($migrationFolder);
            if (!$migrationPage->meta('installable')) {
                $migrationPage->meta()->remove('locked');
                if (is_dir($migrationFolder) and in_array($migrationFolder . 'lockfile.txt', $migrationFiles)) {
                    $this->wire()->files->unlink($migrationFolder . 'lockfile.txt');
                }
            }
        }
        $this->wire()->session->redirect($this->wire()->urls->admin . 'page/edit/?id=' . $pageId);
    }

    /**
     *  Execute method for Preview - linked by button in runtime_markup_migrationActions
     * @return string
     * @throws WireException
     */
    public function ___executePreviewDiffs() {
        $pageId = $this->wire()->input->get->int('id');
        $comparisonType = $target = $this->wire()->input->get->text('target');
        $target = ($target == 'export') ? 'install' : $target;  // export comparison is same as install, but with different text
        $migrationPage = $this->wire()->pages->get($pageId);
        /* @var $migrationPage DbMigrationPage */
        $diffs = $target . 'edDataDiffs';  // e.g. uninstalledDataDiffs
        $newOld = [];
        switch ($target) {
            case 'install' :
                $newOld = ['current', 'new'];
                break;
            case 'uninstall' :
                $newOld = ['current', 'old'];
                break;
            case 'review' :
                $newOld = ['old', 'new'];
                break;
        }
        $compare = $migrationPage->exportData('compare');
        //bd($compare, 'result');
        $arrayComparison = $compare[$diffs];
        //bd($arrayComparison, 'array comparison');
        $col1 = ($target == 'review') ? 'pre-installation' : 'current';
        $col2 = ($target == 'review') ? 'post-installation' : $comparisonType;
        $out = "<h1>Differences between $col1 and $col2 data</h1>";
        if (!$arrayComparison) {
            if ($compare['installedMigrationDiffs']) {
                $out .= '<h2>No data differences, but there are other differences in the migration definition.</h2>';
            } else {
                $out .= '<h2>No differences</h2>';
                return $out;
            }
        }
        if (!is_array($arrayComparison)) {
            $out .= '<h2>Invalid comparison</h2>';
            return $out;
        }
        $out .= '<div class="uk-overflow-auto">';
        $out .= '<table class="uk-table uk-table-divider uk-table-hover" style="white-space: pre-wrap; table-layout: fixed; width: 100%"><thead style="font-weight:bold"><tr><th class="uk-width-1-5">Key</th><th class="uk-width-2-5">' . $col1 . '</th><th class="uk-width-2-5">' . $col2 . '</th></tr></thead>';
        $out .= '<tbody>';
        foreach ($arrayComparison as $key => $value) {
            $out .= '<tr style="font-style:italic"><td>' . $key . '</td>';
//            $re = '/(.*)->/mU';
//            preg_match($re, $key, $matches);
//            $type = $matches[0][1];
//            $action = $matches[1][1];
            $out .= ($value) ? $this->formatCompare($migrationPage, $value, $key, $newOld) : '';
            $out .= '</tr>';
        }
        if ($compare['installedMigrationDiffs']) {
            $out .= '<tr><td>Differences in migration definition that do not affect data.json files (but do affect migration.json):</td><td></td></tr>';
            foreach ($compare['installedMigrationDiffs'] as $key => $value) {
//                $re = '/(.*)->/mU';
//                preg_match($re, $key, $matches);
//                $type = $matches[0][1];
//                $action = $matches[1][1];
                $out .= '<tr style="font-style:italic"><td>' . $key . '</td>';
                $out .= ($value) ? $this->formatCompare($migrationPage, $value, $key, $newOld) : $value;
                $out .= '</tr>';
            }
        }
        $out .= '</tbody></table></div>';
        return $out;
    }


    /**
     * Config inputfields
     * @param InputfieldWrapper $inputfields
     * @throws WireException
     */
    public function getModuleConfigInputfields(InputfieldWrapper $inputfields) {
        $modules = $this->wire('modules');
        $moduleUrl = $this->wire()->urls->siteModules . 'ProcessDbMigrate/';
        if (file_exists($this->modulePath . "help.md")) {
            $help = file_get_contents($this->modulePath . "help.md");
            $help = str_replace('](help/', '](' . $moduleUrl . 'help/' , $help);
            $help = $modules->TextformatterMarkdownExtra->markdown($help);
        } else {
            $help = '';
        }


        /* @var InputfieldMarkup $f */
        $f = $modules->InputfieldMarkup;
        $f_name = 'help';
        $f->name = $f_name;
        $f->label = $this->_('Help');
        $f->description = $this->_('');
        $f->notes = $this->_('');
        $f->columnWidth = 100;
        $f->value = $help;
        $f->collapsed = Inputfield::collapsedYes;
        $inputfields->add($f);

        /* @var InputfieldText $f */
        $f = $modules->InputfieldText;
        $f_name = 'database_name';
        $f->name = $f_name;
        $f->label = $this->_('Database name');
        $f->description = $this->_('Optional name for this database - to tag migrations exported from it.');
        $f->notes = $this->_('If used, any migrations exported from this database will be tagged with its name. 
            Imported migrations tagged with this name will be treated as exportable, not installable (see help for more detail).');
        $f->columnWidth = 75;
        $f->value = $this->$f_name;
        $inputfields->add($f);

        /* @var InputfieldCheckbox $f */
        $f = $modules->InputfieldCheckbox;
        $f_name = 'show_name';
        $f->name = $f_name;
        $f->label = $this->_('Show database name in notice');
        $f->description = $this->_('Display the database name as a notice in every admin page.');
//        $f->notes = $this->_('');
        $f->columnWidth = 25;
        $f->value = $this->$f_name;
        $f->checked = ($f->value == 1) ? 'checked' : '';
        $inputfields->add($f);

        /* @var InputfieldTextarea $f */
        $f = $modules->InputfieldTextarea;
        $f_name = 'exclude_fieldtypes';
        $f->name = $f_name;
        $f->label = $this->_('Exclude Field types');
        $f->description = $this->_('Field types that are selected here will be excluded from page migrations. Enter the field type as text, (comma-separated for multiple types).');
        $f->notes = $this->_('RuntimeMarkup and RuntimeOnly field types are excluded anyway as they do not hold data.'); //RuntimeMarkup and RuntimeOnly are names
        $f->columnWidth = 33;
        $f->value = $this->$f_name;
        $inputfields->add($f);

        /* @var InputfieldTextarea $f */
        $f = $modules->InputfieldTextarea;
        $f_name = 'exclude_fieldnames';
        $f->name = $f_name;
        $f->label = $this->_('Exclude Fields');
        $f->description = $this->_('Fields that are selected here will be excluded from page migrations. Enter the field name as text, (comma-separated for multiple field names).');
        $f->notes = $this->_('For example fields which do not hold data.');
        $f->columnWidth = 33;
        $f->value = $this->$f_name;
        $inputfields->add($f);

        /* @var InputfieldTextarea $f */
        $f = $modules->InputfieldTextarea;
        $f_name = 'exclude_attributes';
        $f->name = $f_name;
        $f->label = $this->_('Exclude Attributes');
        $f->description = $this->_('Attributes that are selected here will be excluded from template and field migrations. Enter the attribute name as text, (comma-separated for multiple attributes).');
        $f->notes = $this->_("For example differences in CKEditor plugins that you don't want reported.");
        $f->columnWidth = 33;
        $f->value = $this->$f_name;
        $inputfields->add($f);


    }

    /**
     * Currently just used in the module, but seems to be a useful function
     * @param array $array
     * @return int
     */
    public function array_depth(array $array) {
        $max_depth = 1;
        foreach ($array as $value) {
            if (is_array($value)) {
                $depth = $this->array_depth($value) + 1;

                if ($depth > $max_depth) {
                    $max_depth = $depth;
                }
            }
        }
        return $max_depth;
    }

}
