<?php namespace ProcessWire;

/**
 * ProcessWire DbMigrate
 * by Mark Evens
 * with tips and snippets from Adrian Jones, Bernhard Baumrock and Robin Sallis
 *
 * Class ProcessDbMigrate
 *
 * A module to manage migrations through the PW GUI
 *
 * @package ProcessWire
 *
 * INFO-DERIVED PROPERTIES
 * ==================
 * @property string $name
 * @property string $parent Path to parent
 * @property string $parentUrl Url to parent
 * @property string $parentHttpUrl Full HttpUrl to parent
 * @property string $title
 * @property string $adminProcess
 *
 * MODULE CONFIGURATION PROPERTIES
 * ===============================
 * @property string $help The help md
 * @property string $database_name User-assigned name of the current database
 * @property boolean $show_name Show database name as message on all admin
 * @property string $exclude_fieldtypes Field types to always exclude from migrations
 * @property string $exclude_fieldnames Field names to always exclude from migrations
 * @property string $exclude_attributes Object attributes to always exclude from migrations
 * @property boolean $auto_install Disable auto-install of bootstrap on upgrade
 * @property boolean $prevent_overlap Prevent page changes where the page is within the scope of an unlocked installable migration
 *
 * OTHER SETTING PROPERTIES
 * ================================
 * @property object $migrations The parent page for migration pages
 * @property object $comparisons The parent page for comparison pages
 * @property object $migrationTemplate The template for migration pages
 * @property object $comparisonTemplate The template for comparison pages
 * @property object $migrationsTemplate The template for the parent page
 * @property string $migrationsPath Path to the directory holding the migrations .json files
 * @property string $comparisonsPath Path to the directory holding the comparisons .json files
 * @property string $modulePath Path to this module
 * @property string $bootstrapPath Path to the directory holding the original bootstrap data (it is copied to migrationsPath on installation)
 * @property DbMigrationPage $bootstrap
 * @property string $adminPath Path to the admin root (page id = 2)
 * @property string $adminUrl Url to admin root
 * @property string $adminHttpUrl Full url to admin root
 *
 *
 * TEMP PROPERTIES
 * ================
 * @property boolean $first
 *
 * HOOKABLE METHODS
 * =================
 * @method array|string execute() Display setup page
 * @method string executeDatabaseComparison() Display database comparison setup page
 * @method void executeGetComparisons() Refresh comparisons
 * @method void executeGetMigrations() Refresh comparisons
 * @method void exportData($migrationPage) Export json from migration definition or compare with json
 * @method void install($upgrade = false) Install or upgrade the module
 * @method void installMigration($migrationPage) Install the specified migration
 * @method void lockMigration($migrationPage, $migrationFolder) Lock the migration
 * @method void newPage($template, $parent, $title, $values) Create new migration or comparison page
 * @method string previewDiffs($migrationPage, $comparisonType, $button) Preview migration differences
 * @method void removeFiles($migrationPage, $oldOnly = false) Remove json files for migration
 * @method void uninstallMigration($migrationPage) Uninstall (roll back) the specified migration
 * @method void unlockMigration($migrationPage, $migrationFolder) Unlock the migration
 * @method void upgrade($fromVersion, $toVersion) Upgrade the module
 *
 */
class ProcessDbMigrate extends Process implements Module, ConfigurableModule {

	/*
	 * Name of template for migration pages
	 *
	 */
	const MIGRATION_TEMPLATE = 'DbMigration';
	/*
	 * Name of template for comparison pages
	 *
	 */
	const COMPARISON_TEMPLATE = 'DbComparison';
	/*
	 * Name of template for parent to migration and comparison pages
	 *
	 */
	const MIGRATION_PARENT_TEMPLATE = 'DbMigrations';
	/*
	 * Name os parent page for migration pages
	 *
	 */
	const MIGRATION_PARENT = 'dbmigrations/';
	/*
	 * Name os parent page for comparison pages
	 *
	 */
	const COMPARISON_PARENT = 'dbcomparisons/';
	/*
	 * (Partial) path to migrations
	 *
	 */
	const MIGRATION_PATH = 'DbMigrate/migrations/';
	/*
	 * (Partial) path to comparisons
	 *
	 */
	const COMPARISON_PATH = 'DbMigrate/comparisons/';
	/*
	 * Prefix to use for migrations created from comparisons
	 *
	 */
	const XCPREFIX = 'xc-';
	/*
	 * The admin path of the source used to create the bootstrap json
	 *
	 */
	const SOURCE_ADMIN = '/processwire/';
	/*
	 * Field types to always ignore in migrations
	 *
	 */
	const EXCLUDE_TYPES = array('RuntimeMarkup', 'RuntimeOnly', 'DbMigrateRuntime');
	/*
	 * Field and template attributes to always ignore in migrations
	 *
	 */
	const EXCLUDE_ATTRIBUTES = array('_importMode', 'template_id');

	/**
	 * Construct
	 * Set default values for configuration settings
	 */
	public function __construct() {
		parent::__construct();
		$this->set('auto_install', 1);
		$this->set('prevent_overlap', 1);
	}

	/**
	 * Called when ProcessWire’s API is ready (optional)
	 *
	 * This optional method is similar to that of init() except that it is called
	 * after the current $page has been determined and the API is fully ready to use.
	 * Use this method instead of (or in addition to) the init() method if your
	 * initialization requires that the `$page` API variable is available.
	 *
	 * @throws WireException
	 *
	 */
	public function ready() {
		$this->addHookBefore("Pages::save()", $this, 'beforeSave');

		$this->addHookBefore("Inputfield::exportConfigData()", $this, 'beforeExportConfigData');

		// Trigger ready() in the Page Class (actually trigger all page classes)
		$page = $this->wire()->page;
		if($page and $page->template == 'admin') {
			$pId = $this->wire()->input->get->int('id');
			$p = $this->wire('pages')->get($pId);
		}
		if(isset($p) and $p and $p->id and method_exists($p, 'ready')) $p->ready();

		// Show the database name if selected in config, but only for admins with permission (and superuser)
		if($this->database_name and $this->show_name and wire('user')->hasPermission('admin-dbMigrate')) {
			$this->wire()->message('DATABASE NAME = ' . $this->database_name);
		}

		// Load .js file and pass variables
		$this->wire()->config->scripts->add($this->wire()->urls->siteModules . 'ProcessDbMigrate/ProcessDbMigrate.js');
		$this->wire->config->js('ProcessDbMigrate', [
			'confirmDelete' => $this->_('Please confirm that this migration is not used in any other database before deleting it.
If it has been used in another environment and is no longer wanted then you will need to remove any orphan json files there manually.')
		]);

		/*
		* Install the bootstrap if it exists, is installable and is not installed
		* NB this cannot be done as part of install() as not all the required API is present until ready() is called
		*/
		if($this->auto_install) {
			$temp = $this->migrationTemplate;
			$bootstrap = $this->wire()->pages->get("template=$temp, name=bootstrap");
			/* @var $bootstrap DbMigrationPage */
			if($bootstrap and $bootstrap->id and $bootstrap->meta('installable')
				and (!$bootstrap->meta('installedStatus')['installed'] or $this->session->get('upgraded'))) {
				try {
					$bootstrap->refresh();
				} catch(WirePermissionException $e) {
					$this->wire()->session->warning($this->_('You do not have permission'));
				} catch(WireException $e) {
					$this->wire()->session->warning($this->_('Unable to refresh bootstrap'));
				}
				try {
					$bootstrap->installMigration('new');
				} catch(WirePermissionException $e) {
					$this->wire()->session->warning($this->_('You do not have permission'));
				} catch(WireException $e) {
					$this->wire()->session->warning($this->_('Unable to install bootstrap'));
				}
				$this->session->remove('upgraded');
			}
			if($this->session->get('upgrade0.1.0')) {
				// remove the old RuntimeOnly fields if upgrading to 0.1.0
				foreach(['dbMigrateActions', 'dbMigrateControl', 'dbMigrateReady'] as $name) {
					$object = $this->wire('fields')->get($name);
					if($object) {
						$n = $object->name;
						$object->flags = Field::flagSystemOverride;
						$object->flags = 0;
						$object->save();
						try {
							$this->wire('fields')->delete($object);
						} catch(WireException $e) {
							$this->wire()->session->error('Object: ' . $object . ': ' . $e->getMessage());
							//bd($n, 'ERROR IN DELETION - ' . $e->getMessage());
						}
					}
				}
				$this->session->remove('upgrade0.1.0');
			}
		}
	}

	/**
	 *
	 * Upgrade the module
	 *
	 * @param int|string $fromVersion
	 * @param int|string $toVersion
	 * @throws WireException
	 * @throws WirePermissionException
	 *
	 */
	public function ___upgrade($fromVersion, $toVersion) {
		$this->session->set('upgraded', true);
		// Versions >= 0.1.0 use FieldtypeDbMigrateRuntime not RuntimeOnly
		if(version_compare($toVersion, '0.1.0', '>=')
			and version_compare($fromVersion, '0.1.0', '<')) {
			// add the new fieldtype
			$this->wire()->modules->install('FieldTypeDbMigrateRuntime');
			// set session var to allow removal of old fields
			$this->session->set('upgrade0.1.0', true); // session var set here is used in ready() as old fields cannot be removed until after bootstrap install
		}
		$this->___install(true);
	}

	/**
	 *
	 * Install/upgrade the module
	 *
	 * @param false $upgrade
	 * @throws WireException
	 * @throws WirePermissionException
	 *
	 */
	public function ___install($upgrade = false) {
		//bd('install');
		$this->init();  // Need the properties to be loaded for the bootstrap, but init() is not called before install()
		$this->bootstrap($upgrade);
		$this->init();  // re-initialise now everything should be there
		if(!$this->migrations or !$this->migrations->id) {
			$this->wire->session->error($this->_('Bootstrap failed'));
			return;
		}
		$setupPage = $this->wire->pages->get("name={$this->name}, parent={$this->parent}");
		if(!$setupPage or !$setupPage->id) {
			// Create the admin page
			$p = $this->wire(new Page());
			$p->template = 'admin';
			$p->name = $this->name;
			$p->parent = $this->parent;
			$p->title = $this->title;
			$p->process = $this->adminProcess;
			$p->save();
		}
	}

	/**
	 * Initialize the module
	 *
	 * ProcessWire calls this method when the module is loaded. At this stage, all
	 * module configuration values have been populated.
	 *
	 * For “autoload” modules (such as this one), this will be called before ProcessWire’s API is ready.
	 * This is a good place to attach hooks (as is the “ready” method).
	 *
	 */
	public function init() {
		require_once('DbMigrationPage.class.php');
		require_once('DbComparisonPage.class.php');
		$this->wire()->modules->get('JqueryWireTabs');
		// Set properties
		$this->set('adminPath', wire('pages')->get(2)->path());
		$this->set('adminUrl', wire('pages')->get(2)->url());
		$this->set('adminHttpUrl', wire('pages')->get(2)->httpUrl());
		$this->set('name', self::getModuleinfo()['page']['name']);
		$this->set('parent', $this->adminPath . self::getModuleinfo()['page']['parent'] . '/');
		$this->set('parentUrl', $this->adminUrl . self::getModuleinfo()['page']['parent'] . '/');
		$this->set('parentHttpUrl', $this->adminHttpUrl . self::getModuleinfo()['page']['parent'] . '/');
		$this->set('title', self::getModuleinfo()['page']['title']);
		$this->set('adminProcess', str_replace(__NAMESPACE__ . '\\', '', get_class()));
		$this->set('migrations', wire('pages')->get($this->adminPath . self::MIGRATION_PARENT));
		$this->set('comparisons', wire('pages')->get($this->adminPath . self::COMPARISON_PARENT));
		$this->set('migrationTemplate', wire('templates')->get(self::MIGRATION_TEMPLATE));
		$this->set('comparisonTemplate', wire('templates')->get(self::COMPARISON_TEMPLATE));
		$this->set('migrationsTemplate', wire('templates')->get(self::MIGRATION_PARENT_TEMPLATE));
		$this->set('migrationsPath', wire('config')->paths->templates . self::MIGRATION_PATH);
		$this->set('comparisonsPath', wire('config')->paths->templates . self::COMPARISON_PATH);
		$this->set('modulePath', wire('config')->paths->siteModules . basename(__DIR__) . '/');
		$this->set('bootstrapPath', $this->modulePath . 'bootstrap');
		$this->set('bootstrap', wire()->pages->get("parent=$this->migrations, template=$this->migrationTemplate, name=bootstrap"));
		// Need custom uninstall to uninstall bootstrap before uninstalling the module
		$this->addHookBefore("Modules::uninstall", $this, "customUninstall");
		// trigger init in Page class as it is not auto
		if(class_exists('DbMigrationPage')) {
			$p = $this->wire(new DbMigrationPage());
			$p->init();
		}
		if(class_exists('DbComparisonPage')) {
			$p = $this->wire(new DbComparisonPage());
			$p->init();
		}
		// Make sure any migration page is refreshed before loading it and set the 'updated' meta (used to indicate if refresh completed fully)
		$this->addHookBefore('ProcessPageEdit::loadPage', function(HookEvent $event) {
			$id = $event->arguments(0);
			$p = $this->pages->get($id);
			if($p and $p->id and ($p->template == self::MIGRATION_TEMPLATE or $p->template == self::COMPARISON_TEMPLATE)) {
				/* @var $p DbMigrationPage */
				$p->meta('updated', false);
				$updated = $p->refresh();
				//bd($updated, 'meta updated');
				$p->meta('updated', $updated);
			}
		});

		//bd('INIT DONE');
	}

	public static function getModuleinfo() {
		return [
			'permanent' => false,        // true if module is permanent and thus not uninstallable (3rd party modules should specify 'false')
			'title' => 'ProcessDbMigrate',
			'summary' => 'Manage migrations via the PW GUI',
			'comments' => 'Document and manage migrations. Allow roll-back and database comparisons.',
			'author' => 'Mark Evens',
			'version' => "0.1.0", // Versions >= 0.1.0 use FieldtypeDbMigrateRuntime not RuntimeOnly
			'autoload' => true,
			'singular' => true,
			'page' => array(            // optionally install/uninstall a page for this process automatically
				'name' => 'dbmigrations',    // name of page to create
				'parent' => 'setup',    // parent name (under admin) or omit or blank to assume admin root
				'title' => 'Database Migrations',    // title of page, or omit to use the title already specified above
			),
			'icon' => 'upload',
			'requires' => ['ProcessWire>=3.0.148'],
			'installs' => ['FieldtypeDbMigrateRuntime'], // Runtime field type for use with this module
			'permission' => 'admin-dbMigrate',         // ToDo refine permissions?
		];
	}

	/**
	 * Install the bootstrap page
	 *
	 * @param boolean $upgrade True for upgrade only.
	 * @throws WireException
	 * @throws WirePermissionException
	 *
	 */
	protected function bootstrap($upgrade = false) {
		// copy the bootstrap files to templates directory
		if(!is_dir($this->migrationsPath . 'bootstrap/')) if(!wireMkdir($this->migrationsPath . 'bootstrap/', true)) {
			throw new WireException($this->_('Unable to create migration directory') . ": {$this->migrationsPath}bootstrap/");
		}
		$this->wire()->files->copy($this->bootstrapPath, $this->migrationsPath . 'bootstrap/');

		// Before we are able to use the copied .json files, we need to check and amend the admin root in use as it may differ in the target system
		if($this->adminPath != self::SOURCE_ADMIN) {
			$jsonFiles = ['/new/data.json', '/new/migration.json', '/old/data.json', '/old/migration.json'];
			foreach($jsonFiles as $jsonFile) {
				$json = (file_exists($this->migrationsPath . 'bootstrap' . $jsonFile))
					? file_get_contents($this->migrationsPath . 'bootstrap' . $jsonFile) : null;
				if($json) {
					$json = str_replace(self::SOURCE_ADMIN, $this->adminPath, $json);
					file_put_contents($this->migrationsPath . 'bootstrap' . $jsonFile, $json);
				}
			}
		}
		if(!$upgrade) {
			// Install a dummy bootstrap using the copied/amended files
			$className = 'ProcessWire\\' . self::MIGRATION_TEMPLATE . 'Page';
			$dummyBootstrap = $this->wire(new $className());  // dummy migration
			/*
			 * NB we cannot assign a template to dummy-bootstrap as we need to run it to create the template!!
			 */
			$dummyBootstrap->name = 'dummy-bootstrap';
			$dummyBootstrap->installMigration('new');
		}
		/* NB For upgrades, bootstrap installation is run by ready() if the new bootstrap is not installed
		It cannot be run here as not all the API is present
		*/
	}

	/**
	 * Custom uninstall routine
	 *
	 * @param $event
	 * @throws WireException
	 *
	 */
	public function customUninstall($event) {
		$class = $event->arguments(0);
		if(__NAMESPACE__ . '\\' . $class != __CLASS__) return;
		//bd('IN CUSTOM UNINSTALL - uninstalling....');
		$abort = false;

		// Make sure there is a bootstrap page
		$setupPage = $this->wire()->pages->get($this->adminPath . 'setup/dbmigrations/');
		if($setupPage and $setupPage->id) {
			if(!$this->bootstrap or !$this->bootstrap->id) {
				$this->error($this->_('Uninstall of bootstrap failed.') . "\n" .
					$this->_('No bootstrap page  - try going to setup page and refreshing before uninstalling'));
				$abort = true;
			}
		} else {
			//bd('NO SETUP PAGE');
			$event->return;
			return;
		}
		//Check all templates with dbMigrate tags to ensure there are no migration pages
		$taggedTemplates = wire()->templates->find("tags=dbMigrate");
		$templateList = $taggedTemplates->implode('|', 'name');
		$pagesUsingTemplates = wire()->pages->find("template=$templateList");
		if($pagesUsingTemplates and $pagesUsingTemplates->count() > 0) {
			foreach($pagesUsingTemplates as $pageUsingTemplate) {
				if(($pageUsingTemplate->template == self::MIGRATION_TEMPLATE or $pageUsingTemplate->template == self::COMPARISON_TEMPLATE)
					and $pageUsingTemplate->name != 'bootstrap') {
					$this->error($this->_('Uninstall aborted as there are migration and/or comparison pages. Delete all comparison pages and all migration pages except for bootstrap before uninstalling.'));
					$event->replace = true; // prevents original uninstall
					$this->session->redirect("./edit?name=$class"); // prevent "module uninstalled" message
					break;
				}
			}
		}

		// unset system flags on templates and fields
		$dbMigrateTemplates = wire()->templates->find("tags=dbMigrate");
		foreach($dbMigrateTemplates as $t) {
			$t->flags = Template::flagSystemOverride;
			$t->flags = 0;
			foreach($t->fieldgroup as $f) {
				$f->flags = Field::flagSystemOverride;
				$f->flags = 0;
			}
		}
		$dbMigrateFields = wire()->fields->find("tags=dbMigrate");
		foreach($dbMigrateFields as $f) {
			$f->flags = Field::flagSystemOverride;
			$f->flags = 0;
		}
		// uninstall if there is a valid 'old' directory
		if(!$abort) {
			$this->bootstrap->ready();  // Need the properties to be loaded for the uninstall, but ready() is not called before uninstall()
			try {
				//bd('uninstalling bootstrap');
				$this->bootstrap->installMigration('old');
			} catch(WireException $e) {
				//bd($e, 'WireException');
				$msg = $e->getMessage();
				$this->error($this->_('Uninstall of bootstrap failed or incomplete.') . "\n $msg \n" .
					$this->_('Re-install the module and fix the cause of the problem before uninstalling again.'));
				$abort = false; //allow uninstall to complete as re-installation of bootstrap may be required to enable proper uninstallation
			}
		}
		// uninstall?
		if($abort) {
			//bd('ABORTING UNINSTALL');
			// there were some non-critical errors
			// close without uninstalling module -
			$event->replace = true; // prevents original uninstall
			$this->session->redirect("./edit?name=$class"); // prevent "module uninstalled" message
		}
	}

	/**
	 * Main admin page - list migrations & allows creation of new migration
	 *
	 * @return array|string
	 * @throws WireException
	 * @throws WirePermissionException
	 *
	 */
	public function ___execute() {
		$pageEdit = $this->wire('urls')->admin . 'page/edit/?id=';

		$form = $this->modules->get("InputfieldForm");
		$prepend = '<ul class="WireTabs uk-tab" uk-switcher>' .
			'<li id="migrations-tab"><a href="#migrations">Migrations</a></li>' .
			'<li id="database-comparisons-tab"><a href="#database-comparisons">Database comparisons</a></li>' .
			'</ul>';
		// uk-switcher uk-margin classes need to be added to <ul> parent of fieldset - in the js
		$form->set('prependMarkup', $prepend);

		// create a fieldset for migrations
//        $fieldset = $this->modules->get("InputfieldFieldset");
//        $fieldset->label = "Migrations";
//        $fieldset->attr('id+name', 'migrations');
		$field = $this->modules->get("InputfieldMarkup");

		$field->attr('id+name', 'migrations');
		$field->set('themeBorder', 'line');

		$table = $this->wire('modules')->get("MarkupAdminDataTable");
		$table->headerRow(['Name', 'Type', 'Status', 'Title', 'Summary', 'Items', 'Created']);
		$table->setSortable(true);
		$table->setEncodeEntities(false);
		$this->moduleRefresh();
		$migrationPages = $this->migrations->find("template=$this->migrationTemplate, sort=-created, include=all");
		foreach($migrationPages as $migrationPage) {
			/* @var $migrationPage DbMigrationPage */
			$installedStatus = $migrationPage->meta('installedStatus');
			$status = $installedStatus['status'];
			if(!$migrationPage->meta('locked')) {
				if($migrationPage->meta('installable')) {
					$statusColour = ($status == 'installed') ? 'lightgreen' : (($status == 'uninstalled') ? 'salmon' : 'orange');
				} else {
					$statusColour = ($status == 'exported') ? 'lightgreen' : 'salmon';
				}
			} else {
//                $status = 'Locked';
				$statusColour = 'LightGrey';
			}
			//bd($migrationPage, $status);
			//bd($installedStatus);
			$lockIcon = ($migrationPage->meta('locked')) ? '<i class="fa fa-lock"></i>' : '<i class="fa fa-unlock"></i>';
			$itemList = [];
			foreach($migrationPage->dbMigrateItem as $migrateItem) {
				/* @var $migrateItem RepeaterDbMigrateItemPage */
				$oldName = ($migrateItem->dbMigrateOldName) ? '|' . $migrateItem->dbMigrateOldName : '';
				$itemList[] = '<em>' . $migrateItem->dbMigrateAction->title . ' ' . $migrateItem->dbMigrateType->title . '</em>: ' . $migrateItem->dbMigrateName . $oldName;
			}
			$itemsString = implode("    ", $itemList);
			$data = array(
				// Values with a string key are converter to a link: title => link
				$migrationPage->name => $pageEdit . $migrationPage->id,
				($migrationPage->meta('installable')) ? '<span class="fa fa-arrow-down"></span>' : '<span class="fa fa-arrow-up"></span>',
				$lockIcon . ' <span style="background:' . $statusColour . '">' . $status . '</span>',
				$migrationPage->title,
				$migrationPage->dbMigrateSummary,
				$itemsString,
				date('Y-m-d', $migrationPage->created),
			);
			$table->row($data);

		}
		$this->wire('modules')->get('JqueryUI')->use('modal');
		$out = '<div><h3>' . $this->_('Existing migrations are listed below. Go to the specific migration page for any actions.') . '</h3><p>' .
			$this->_('Exportable migrations') . ' - <span class="fa fa-arrow-up"></span> - ' .
			$this->_('originated in this database, can be edited here and are a source of a migration to be installed elsewhere.') . '</p><p>' .
			$this->_('Installable migrations') . ' - <span class="fa fa-arrow-down"></span> - ' .
			$this->_('originated from another database and can be installed/uninstalled here (except that "bootstrap" cannot be uninstalled). They cannot be changed except in the original database.') . '</p><p>' .
			$this->_('Locked migrations') . ' - <span class="fa fa-lock"></span> - ' .
			$this->_('can no longer be changed or actioned.') . '</p></div><div>';
		$out .= $table->render();
		$btnAddNew = $this->createNewButton($this->migrationTemplate, $this->migrations); //createNewButton also allows title and values to be set, but not used here
		$out .= $btnAddNew->render();
		$btn = $this->wire('modules')->get("InputfieldButton");
		$btn->attr('href', './get-migrations/');
		$btn->attr('id', "get_migrations");
		$btn->attr('value', "Refresh migrations");
		$btn->showInHeader();
		$out .= $btn->render();

		$field->value = $out;
		$form->append($field);

		$field = $this->modules->get("InputfieldMarkup");
		$field->attr('id+name', 'database-comparisons');
		$table = $this->wire('modules')->get("MarkupAdminDataTable");
		$table->headerRow(['Name', 'Source DB', 'Title', 'Summary', 'Items', 'Created']);
		$table->setSortable(true);
		$table->setEncodeEntities(false);
		$comparisonPages = $this->comparisons->find("template=$this->comparisonTemplate, sort=-created, include=all");
		foreach($comparisonPages as $comparisonPage) {
			/* @var $comparisonPage DbComparisonPage */
			$itemList = [];
			foreach($comparisonPage->dbMigrateComparisonItem as $comparisonItem) {
				/* @var $comparisonItem RepeaterDbMigrateComparisonItemPage */
				$itemList[] = '<em>' . $comparisonItem->dbMigrateType->title . '</em>: ' . $comparisonItem->dbMigrateName;
			}
			$itemsString = implode("    ", $itemList);
			$data = array(
				// Values with a string key are converter to a link: title => link
				$comparisonPage->name => $pageEdit . $comparisonPage->id,
				$comparisonPage->meta('sourceDb'),
				$comparisonPage->title,
				$comparisonPage->dbMigrateSummary,
				$itemsString,
				date('Y-m-d', $comparisonPage->created),
			);
			$table->row($data);

		}
		$this->wire('modules')->get('JqueryUI')->use('modal');
		$out = '<div><h3>' . $this->_('Existing database comparison pages are listed below. Go to the specific page to compare.') . '</h3></div>';
		$out .= $table->render();
		$btnAddNew = $this->createNewButton($this->comparisonTemplate, $this->comparisons); //createNewButton also allows title and values to be set, but not used here
		$out .= $btnAddNew->render();
		$btn = $this->wire('modules')->get("InputfieldButton");
		$btn->attr('href', $this->parent . $this->name . '/get-comparisons/');
		$btn->attr('id', "get_comparisons");
		$btn->attr('value', "Refresh comparisons");
		$btn->showInHeader();
		$out .= $btn->render();
		$field->value = $out;

		$form->append($field);

		return $form->render();
	}

	/**
	 * Refresh all migration pages - called by executeGetMigrations
	 *
	 * @param string $type
	 * @throws WireException
	 * @throws WirePermissionException
	 *
	 */
	public function moduleRefresh($type = 'migrations') {
		//bd('in module refresh');
		$migrationPath = ($type == 'comparisons') ? $this->comparisonsPath : $this->migrationsPath;
		$migrationFiles = $this->wire('files')->find($migrationPath);
		$migrationFiles = array_filter($migrationFiles, function($e) {
			return (basename($e, '.json') == 'migration' and basename(pathinfo($e)['dirname']) == 'new');
		});
		$migrationPages = $this->wire(new PageArray());
		//bd($migrationFiles, 'migration files');
		if($type == 'migrations') {
			if(!$this->migrations or !$this->migrations->id or !$this->wire()->templates->get('DbMigrations')
				or !$this->wire()->templates->get('DbMigration')) {
				$this->wire()->session->error($this->_('No DbMigrations page'));
				$this->wire()->session->redirect('../');
				return;
			}
			$migrationPages = $this->migrations->find("template=$this->migrationTemplate, sort=-modified, include=all");
		}
		if($type == 'comparisons') {
			if(!$this->comparisons or !$this->comparisons->id or !$this->wire()->templates->get('DbMigrations')
				or !$this->wire()->templates->get('DbComparison')) {
				$this->wire()->session->error($this->_('No DbComparisons page'));
				$this->wire()->session->redirect('../');
				return;
			}
			$migrationPages = $this->comparisons->find("template=$this->comparisonTemplate, sort=-modified, include=all");
		}
		$alreadyFound = [];
		foreach($migrationPages as $migrationPage) {
			/* @var $migrationPage DbMigrationPage */
			$migrationDirectory = $migrationPath . $migrationPage->name . '/new/';
			$foundFiles = $this->wire('files')->find($migrationDirectory);
			foreach($foundFiles as $foundFile) {
				if(basename($foundFile, '.json') == 'migration') $alreadyFound[$migrationPage->name] = $foundFile;
			}
		}
		$wantedFiles = array_diff($migrationFiles, array_values($alreadyFound));
		//bd($alreadyFound, '$alreadyFound');
		//bd($wantedFiles, 'wanted files');
		foreach($wantedFiles as $file) {
			//Retrieve the data from our text file.
			$fileContents = wireDecodeJSON(file_get_contents($file));
			//bd($fileContents, 'wanted file contents');
			$sourceDb = null;
			if(isset($fileContents['sourceDb'])) {
				$sourceDb = $fileContents['sourceDb'];
				unset($fileContents['sourceDb']);
			}
			foreach($fileContents as $content) {
				// There should only be one item in this context
				foreach($content as $line) {
					foreach($line as $pathName => $values) {
						$pageName = $values['name'];
						$className = ($type == 'comparisons') ? 'ProcessWire\\' .
							self::COMPARISON_TEMPLATE . 'Page' : 'ProcessWire\\' . self::MIGRATION_TEMPLATE . 'Page';
						$newMigration = $this->wire(new $className());
						$newMigration->of(false);
						$newMigration->name = $pageName;
						$newMigration->parent = ($type == 'comparisons') ? $this->comparisons : $this->migrations;
						$newMigration->template = ($type == 'comparisons') ? 'DbComparison' : 'DbMigration';
						$newMigration->status = 1;
						//bd($values, 'in module refresh with $values');
						$newMigration->save(['noHooks' => true]);
						unset($values['id']);
						unset($values['parent']);
						unset($values['template']);
						unset($values['status']);
						// split out repeaters from values
						$r = $newMigration->getRepeaters($values);
						$repeaters = $r['repeaters'];
						$values = $r['values'];  // values has repeaters removed
						//bd($values, 'wanted values');
						//bd($newMigration, 'newMigration');
						$newMigration->setAndSave($values, ['noHooks' => true, 'quiet' => true]);
						$newMigration->setAndSaveRepeaters($repeaters);
					}
				}
			}
			// To prevent re-saving, show 'Install' and 'Uninstall' buttons and remove 'Export Data' button - implicitly by setting meta('installable'):
			if(isset($newMigration) and $newMigration and $newMigration->id) {
				$newMigration->meta('installable', true);
				$newMigration->meta('sourceDb', $sourceDb);
				// For drafts created from database comparisons, set the 'draft' flag if there is no new/data.json file
				if($sourceDb != $this->database_name and strpos($newMigration->name, self::XCPREFIX) == 0
					and !file_exists($migrationPath . $newMigration->name . '/new/data.json'))
					$newMigration->meta('draft', true);
			}
		}
		foreach($alreadyFound as $pName => $found) {
			$migrationPage = $this->$type->get("name=$pName");
			if($migrationPage and $migrationPage->id) {
				$migrationPage->ready(); // Need to trigger it as not auto
				$migrationPage->meta('updated', false);
				$updated = $migrationPage->refresh($found);
				$migrationPage->meta('updated', $updated);
			}
		}
	}

	/**
	 *
	 * Add a button to create new pages
	 *
	 * @param $tpl
	 * @param $page
	 * @param null $title
	 * @param array $values
	 * @return array|array[]|\array[][]|bool|float|int|int[]|mixed|null[]|\null[][]|object|_Module|Field|Fieldtype|Module|NullPage|Page|PageArray|Pages|Permission|Role|SessionCSRF|Template|User|Wire|WireArray|WireData|WireDataDB|WireInputData|string|string[]|\string[][]|null
	 * @throws WireException
	 * @throws WirePermissionException
	 *
	 */
	public function createNewButton($tpl, $page, $title = null, $values = []) {
		$template = wire()->templates->get($tpl);
		$valuesStr = urlencode(serialize($values));
		$titleStr = urlencode($title);
		$btnAddNew = wire('modules')->get("InputfieldButton");
		$btnAddNew->attr('href', $this->parentHttpUrl . $this->name . "/new-page/?template=" . $template->name . "&parent=" .
			$page->id . "&title=" . $titleStr . "&values=" . $valuesStr);
		$btnAddNew->attr('id', "AddPage_" . $template);
		$btnAddNew->attr('value', "Add New " . $template);
		$btnAddNew->showInHeader();
		return $btnAddNew;
	}


	/**
	 *
	 * Create a new page
	 *
	 * @throws WireException
	 *
	 */
	public function executeNewPage() {
		$templateName = $this->wire()->input->get->text("template");
		$template = wire()->templates->get($templateName);  //name
		$parent = $this->wire()->input->get->int("parent");  //id
		$title = urldecode($this->wire()->input->get->text('title'));  //string
		$values = unserialize(urldecode($this->wire()->input->get->text('values'))); //array
		return $this->newPage($template, $parent, $title, $values);
	}

	/**
	 * This is the hookable method for executeNewPage, with the GET variables as arguments
	 *
	 * @param $template
	 * @param $parent
	 * @param $title
	 * @param $values
	 * @throws WireException
	 *
	 */
	public function ___newPage($template, $parent, $title, $values) {

		$className = $template . 'Page';
		$url = './';
		if(!$title) {
			//bd($template, 'template');
			$url = wire('config')->urls->admin . "page/add/?parent_id=" . $parent . "&template_id=" . $template->id;
		} else {
			//bd($className, 'class name');
			$newPage = $this->wire(new $className());
			$newPage->of(false);
			$newPage->title = $title;
			$newPage->save();
			$newPage->setAndSave($values);
		}
		return wire()->session->redirect($url);
	}

	/**
	 *
	 * View the database comparison setup page
	 *
	 * @return string
	 * @throws WireException
	 * @throws WirePermissionException
	 *
	 */
	public function ___executeDatabaseComparison() {
		$pageEdit = $this->wire('urls')->admin . 'page/edit/?id=';

		$table = $this->wire('modules')->get("MarkupAdminDataTable");
		$table->headerRow(['Name', 'Source DB', 'Title', 'Summary', 'Items', 'Created']);
		$table->setSortable(true);
		$table->setEncodeEntities(false);
		$comparisonPages = $this->comparisons->find("template=$this->comparisonTemplate, sort=-created, include=all");
		foreach($comparisonPages as $comparisonPage) {
			/* @var $comparisonPage DbComparisonPage */
			$itemList = [];
			foreach($comparisonPage->dbMigrateComparisonItem as $comparisonItem) {
				/* @var $comparisonItem RepeaterDbMigrateComparisonItemPage */
				$itemList[] = '<em>' . $comparisonItem->dbMigrateType->title . '</em>: ' . $comparisonItem->dbMigrateName;
			}
			$itemsString = implode("    ", $itemList);
			$data = array(
				// Values with a string key are converter to a link: title => link
				$comparisonPage->name => $pageEdit . $comparisonPage->id,
				$comparisonPage->meta('sourceDb'),
				$comparisonPage->title,
				$comparisonPage->dbMigrateSummary,
				$itemsString,
				date('Y-m-d', $comparisonPage->created),
			);
			$table->row($data);

		}
		$this->wire('modules')->get('JqueryUI')->use('modal');
		$out = '<div><h3>' . $this->_('Existing database comparison pages are listed below. Go to the specific page to compare.') . '</h3></div>';
		$out .= $table->render();
		try {
			$btnAddNew = $this->createNewButton($this->comparisonTemplate, $this->comparisons);
		} catch(WireException $e) {
			$this->wire()->session->error($this->_('Error in creating button'));
		}
		//createNewButton also allows title and values to be set, but not used here
		$out .= $btnAddNew->render();
		$btn = $this->wire('modules')->get("InputfieldButton");
		$btn->attr('href', $this->parent . $this->name . '/get-comparisons/');
		$btn->attr('id', "get_comparisons");
		$btn->attr('value', "Refresh");
		$btn->showInHeader();
		$out .= $btn->render();
		return $out;
	}

	/**
	 * Execute method for refresh Linked by Refresh button on this page
	 *
	 * @throws WireException
	 * @throws WirePermissionException
	 *
	 */
	public function ___executeGetMigrations() {
		$this->moduleRefresh();
		$this->wire()->session->redirect('../#migrations-tab');
	}

	/**
	 * Execute method for refresh Linked by Refresh button on this page
	 *
	 * @throws WireException
	 * @throws WirePermissionException
	 *
	 */
	public function ___executeGetComparisons() {
		$this->moduleRefresh('comparisons');
		$this->wire()->session->redirect('../#database-comparisons-tab');
	}

	/**
	 * Execute method for export - linked by button in dbMigrateActions
	 *
	 * @throws WireException
	 *
	 */
	public function executeExportData() {
		$pageId = $this->wire()->input->get->int('id');
		$type = $this->wire()->input->get->text('type');
		$migrationPage = $this->wire()->pages->get($pageId);
		if($type == 'comparison') {
			/* @var $migrationPage DbComparisonPage */
		} else {
			/* @var $migrationPage DbMigrationPage */
		}
		$this->exportData($migrationPage);
		$this->wire()->session->redirect($this->wire()->urls->admin . 'page/edit/?id=' . $pageId);
	}

	/**
	 * This is the hookable method for export - it has the migration page as an argument
	 *
	 * @param $migrationPage
	 * @throws WireException
	 * @throws WirePermissionException
	 *
	 */
	public function ___exportData($migrationPage) {
		/* @var $migrationPage DbMigrationPage */
		$migrationPage->exportData('new');
		$migrationPage->exportData('compare');
	}

	/**
	 * Execute method for removing files - linked by button in dbMigrateActions
	 *
	 * @throws WireException
	 *
	 */
	public function executeRemoveFiles() {
		$pageId = $this->wire()->input->get->int('id');
		$oldOnly = ($this->wire()->input->get->int('oldOnly') == 1);
		$migrationPage = $this->wire()->pages->get($pageId);
		/* @var $migrationPage DbMigrationPage */
		$this->removeFiles($migrationPage, $oldOnly);
		$this->wire()->session->redirect($this->wire()->urls->admin . 'page/edit/?id=' . $pageId);
	}

	/**
	 * This is the hookable method for removing files - it has the migration page as an argument
	 *
	 * @param $migrationPage
	 * @param bool $oldOnly
	 * @throws WireException
	 * @throws WirePermissionException
	 *
	 */
	public function ___removeFiles($migrationPage, $oldOnly = false) {
		$type = (get_class($migrationPage) == 'ProcessWire\DbComparisonPage') ? 'comparison' : 'migration';
		if($type == 'comparison') {
			/* @var $migrationPage DbComparisonPage */
			$migrationPath = $this->comparisonsPath . $migrationPage->name . '/';
		} else {
			/* @var $migrationPage DbMigrationPage */
			$migrationPath = $this->migrationsPath . $migrationPage->name . '/';
		}
		if(is_dir($migrationPath)) {
			if($oldOnly) {
				$this->wire()->files->rmdir($migrationPath . 'old/', true);
				$migrationPage->refresh();
			} else {
				$this->wire()->files->rmdir($migrationPath, true);
			}
		}
	}

	/**
	 * Execute method for install - linked by button in dbMigrateActions
	 *
	 * @throws WireException
	 * @throws WirePermissionException
	 *
	 */
	public function executeInstallMigration() {
		$pageId = $this->wire()->input->get->int('id');
		$migrationPage = $this->wire()->pages->get($pageId);
		/* @var $migrationPage DbMigrationPage */
		$this->installMigration($migrationPage);
		$this->wire()->session->redirect($this->wire()->urls->admin . 'page/edit/?id=' . $pageId);
	}

	/**
	 * This is the hookable method for install - it has the migration page as an argument
	 *
	 * @param $migrationPage
	 * @throws WireException
	 * @throws WirePermissionException
	 *
	 */
	public function ___installMigration($migrationPage) {
		/* @var $migrationPage DbMigrationPage */
		$migrationPage->installMigration('new');
	}

	/**
	 * Execute method for uninstall - linked by button in dbMigrateActions
	 *
	 * @throws WireException
	 * @throws WirePermissionException
	 *
	 */
	public function executeUninstallMigration() {
		$pageId = $this->wire()->input->get->int('id');
		$migrationPage = $this->wire()->pages->get($pageId);
		/* @var $migrationPage DbMigrationPage */
		$this->uninstallMigration($migrationPage);
		$this->wire()->session->redirect($this->wire()->urls->admin . 'page/edit/?id=' . $pageId);
	}

	/**
	 * This is the hookable method for uninstall - it has the migration page as an argument
	 *
	 * @param $migrationPage
	 * @throws WireException
	 * @throws WirePermissionException
	 *
	 */
	public function ___uninstallMigration($migrationPage) {
		/* @var $migrationPage DbMigrationPage */
		$migrationPage->installMigration('old');
	}

	/**
	 * Lock the migration linked by dbMigrateControl
	 *
	 * @throws WireException
	 *
	 */
	public function executeLock() {
		$pageId = $this->wire()->input->get->int('id');
		$action = $this->wire()->input->get->text('action');
		$migrationPage = $this->wire()->pages->get($pageId);
		$migrationFolder = $this->migrationsPath . $migrationPage->name . '/';
		if($action == 'lock') {
			//bd($migrationPage->meta('locked'), 'Meta locked');
			if(is_dir($migrationFolder)) {
				if(!$migrationPage->meta('installable')) {
					$this->lockMigration($migrationPage, $migrationFolder);
				}
			} else {
				$this->wire()->session->error(sprintf($this->_("Unable to lock migration as no directory named %s exists."), $migrationPage));
			}
		} else {   // 'unlock'
			$migrationFiles = $this->wire()->files->find($migrationFolder);
			if(is_dir($migrationFolder) and in_array($migrationFolder . 'lockfile.txt', $migrationFiles)) {
				if(!$migrationPage->meta('installable')) {
					$this->unlockMigration($migrationPage, $migrationFolder);
				}
			}
		}
		$this->wire()->session->redirect($this->wire()->urls->admin . 'page/edit/?id=' . $pageId);
	}

	/**
	 * This is the hookable method for Lock - it has the migration page as an argument
	 *
	 * @param $migrationPage
	 * @param $migrationFolder
	 * @throws WireException
	 * @throws WirePermissionException
	 *
	 */
	public function ___lockMigration($migrationPage, $migrationFolder) {
		/* @var $migrationPage DbMigrationPage */
		$migrationPage->exportData('compare'); // sets meta('installedStatus') to the latest status before locking
		$now = $this->wire()->datetime->date('Ymd-His');
		$this->wire()->files->filePutContents($migrationFolder . 'lockfile.txt', $now);
		$migrationPage->meta('locked', true);
	}

	/**
	 * This is the hookable method for Unlock - it has the migration page as an argument
	 *
	 * @param $migrationPage
	 * @param $migrationFolder
	 * @throws WireException
	 * @throws WirePermissionException
	 *
	 */
	public function ___unlockMigration($migrationPage, $migrationFolder) {
		/* @var $migrationPage DbMigrationPage */
		$this->wire()->files->unlink($migrationFolder . 'lockfile.txt');
		$migrationPage->meta()->remove('locked');
		$migrationPage->exportData('compare'); // sets meta('installedStatus') to the latest status after unlocking (May cause errors if unlocking superseded migration?)
	}

	/**
	 *  Execute method for Preview - linked by button in dbMigrateActions
	 *
	 * @return string
	 * @throws WireException
	 *
	 */
	public function executePreviewDiffs() {
		$pageId = $this->wire()->input->get->int('id');
		$comparisonType = $this->wire()->input->get->text('target');
		$button = $this->wire()->input->get->text('button');
		$migrationPage = $this->wire()->pages->get($pageId);
		/* @var $migrationPage DbMigrationPage */
		return $this->previewDiffs($migrationPage, $comparisonType, $button);
	}

	/**
	 * This is the hookable method for PreviewDiffs - it has the migration page as an argument
	 *
	 * @param $migrationPage
	 * @param $comparisonType
	 * @param $button
	 * @return string
	 * @return string
	 * @throws WireException
	 * @throws WirePermissionException
	 *
	 */
	public function ___previewDiffs($migrationPage, $comparisonType, $button) {
		if($migrationPage->template == self::COMPARISON_TEMPLATE) {
			$pageType = 'comparison';
			/* @var $migrationPage DbComparisonPage */
		} else {
			/* @var $migrationPage DbMigrationPage */
			$pageType = 'migration';
		}
		if($pageType == 'comparison' and $button == 'draft') {
			// remove any existing draft before creating a new one
			$nameRoot = self::XCPREFIX . $migrationPage->name;
			$drafts = $this->wire()->pages->find("parent=$this->migrations, name^=$nameRoot");
			//bd($this->migrations->path . $nameRoot, 'check existing');
			/*
			 * Delete any existing draft, but ONLY if it is still a draft (given by meta)
			 * Note that the 'draft' meta is removed once there is a data.json file in the migration directory (removal is by RuntimeFields/dbMigrateRuntimeAction.php)
			 */
			$this->wire()->session->set('trash-drafts', true);
			foreach($drafts as $draft) {
				//bd([$draft,$draft->meta('draft')], 'draft meta in loop');
				if($draft and $draft->id and $draft->meta('draft')) {
					$draft->ready(); // to ensure that hooks in DbMigrationPage class are operative
					//bd($draft, 'trashing');
					$draft->trash();  // hook will delete associated migration files
					$draft->delete(true);
				}
			}
			$this->wire()->session->remove('trash-drafts');
			$name = $nameRoot . '-' . $this->datetime->date();

			$draft = $this->wire(new DbMigrationPage());
			$draft->parent = $this->migrations;
			$draft->name = $name;
			$draft->title = $this->_('Generated from comparison') . ' "' . $migrationPage->title . '"';
			$draft->save(['noHooks' => true]);
			$draft->meta('sourceDb', $migrationPage->meta('sourceDb'));
			$draft->meta('draft', true);
			$draft->meta('installable', true);
			//bd($draft->meta('draft'), 'initial draft meta');
		} else {
			$draft = null;
		}
		$target = $comparisonType;
		$target = ($target == 'export') ? 'install' : $target;  // export comparison is same as install, but with different text
		$diffs = $target . 'edDataDiffs';  // e.g. uninstalledDataDiffs
		$newOld = [];
		switch($target) {
			case 'install' :
				$newOld = ['current', 'new'];
				break;
			case 'uninstall' :
				$newOld = ['current', 'old'];
				break;
			case 'review' :
				$newOld = ['old', 'new'];
				break;
		}
		$compare = $migrationPage->exportData('compare');
		//bd($compare, 'result');
		$arrayComparison = $compare[$diffs];
		//bd($arrayComparison, 'array comparison');
		$col1 = ($target == 'review') ? 'pre-installation' : 'current';
		$col2 = ($target == 'review') ? 'post-installation' : $comparisonType;
		if($pageType == 'comparison') $col2 = 'source';
		$out = "<h1>Differences between $col1 and $col2 data</h1>";
		if(!$arrayComparison) {
			if($compare['installedMigrationDiffs']) {
				$out .= '<h2>No data differences, but there are other differences in the migration definition.</h2>';
			} else {
				$out .= '<h2>No differences</h2>';
				if($draft and $draft->id and $draft->meta('draft')) {
					$draft->trash();
					$draft->delete(true);
					$out = $this->_('No draft migration has been created as there are no differences between the databases (per the comparison item)');
					$out .= '<br/>' . $this->_('If you believe there should be differences, try re-exporting the comparison from the source database first.');
				}
				return $out;
			}
		}
		if(!is_array($arrayComparison)) {
			$out .= '<h2>Invalid comparison</h2>';
			return $out;
		}
		$out .= '<div class="uk-overflow-auto">';
		$out .= '<table class="uk-table uk-table-divider uk-table-hover" style="white-space: pre-wrap; table-layout: fixed; width: 100%"><thead style="font-weight:bold"><tr><th class="uk-width-1-5">Key</th><th class="uk-width-2-5">' . $col1 . '</th><th class="uk-width-2-5">' . $col2 . '</th></tr></thead>';
		$out .= '<tbody>';
		$this->first = true;
		foreach($arrayComparison as $key => $value) {
			$keyArray = explode('->', $key); // sets 0, 1 , 2
			$out .= '<tr style="font-style:italic"><td>' . $key . '</td>';
			$out .= ($value) ? $this->formatCompare($migrationPage, $pageType, $value, $key, $newOld, $draft, $keyArray) : '';
			$out .= '</tr>';
			if(!$value and $draft) {
				//bd($draft, 'adding from main __preview');
				$this->addDbMigrateItem($draft, $keyArray, 'new');
			}
		}
		//bd($draft, 'draft in top');
		if($compare['installedMigrationDiffs']) {
			$out .= '<tr><td>Differences in migration definition that do not affect data.json files (but do affect migration.json):</td><td></td></tr>';
			foreach($compare['installedMigrationDiffs'] as $key => $value) {
				$out .= '<tr style="font-style:italic"><td>' . $key . '</td>';
				$out .= ($value) ? $this->formatCompare($migrationPage, $pageType, $value, $key, $newOld, $draft, []) : $value;
				$out .= '</tr>';
			}
		}
		$out .= '</tbody></table></div>';
		if($button == 'draft') {
			$draft->exportData('new');
			$out = '<p>' . $this->_('Draft migration.json file has been created in this directory') . ': ' . $this->migrationsPath . $draft->name . '/</p>';
			$out .= '<p>' . $this->_('You can view the draft migration at ') . '<a href="' . $this->wire()->urls->admin . 'page/edit/?id=' . $draft->id . '">' . $draft->name . '</a></p>';
			$out .= '<p>' . $this->_('However, no actions are available until data has been exported from the source database') . ': ' . $draft->meta('sourceDb') . '</p>';
			$out .= '<p>' . $this->_('Sync the draft migration directory to the source environment.
			 Then go to the source database and review the draft migration - you may need to re-order the items to take account of dependencies.
			 Then export the data and install it on the target environment in the normal way.');
		}
		return $out;
	}

	/**
	 * Markup for the Preview modal
	 *
	 * @param $value
	 * @param int $deep
	 * @param $newOld
	 * @param $key
	 * @param $migrationPage
	 * @param $pageType string For documentation purposes only
	 * @param $draft
	 * @param $keyArray
	 * @return string
	 * @throws WireException
	 *
	 */
	protected function formatCompare($migrationPage, $pageType, $value, $key, $newOld, $draft, $keyArray, $deep = 0) {
		if(!$value) return '';
		if($pageType = 'comparison') {
			/* @var $migrationPage DbComparisonPage */
		} else {
			/* @var $migrationPage DbMigrationPage */
		}
		//bd($value, 'value in formatCompare');
		if($this->array_depth($value) == 1) {
			// at the bottom, there should be an unassociated array of length exactly = 2
			if(count($value) != 2) return '<td style="word-wrap: break-word">' . wireEncodeJSON($value) . '</td><td>' .
				'Item is not a pair' . '</td>';
			foreach($newOld as $col => $type) {
				if($type != 'current' and strpos($key, 'pages') === 0 and $value[$col] != strip_tags($value[$col])) {
					$value[$col] = $migrationPage->replaceImgSrcPath($value[$col], $type);
				}
			}
			if($draft) {
				$this->updateDraft($draft, $keyArray, $value);
			}
			return '<td style="word-wrap: break-word">' . $value[0] . '</td><td style="word-wrap: break-word">' .
				$value[1] . '</td>';
		}

		//bd($value, 'depth >= 2 value');
		if(count($value) == 2) {
			// check that one item is not a string, so we don't iterate further in  that case
			$a0 = array_slice($value, 0, 1, true);
			$a1 = array_slice($value, 1, 1, true);
			$v[0] = reset($a0);
			$v[1] = reset($a1);
			if(is_string($v[0]) or is_string($v[1])) {
				//bd($value, 'depth 2 count 2 value where one element is a string');
				foreach($newOld as $col => $type) {
					$v[$col] = (is_array($v[$col])) ? wireEncodeJSON($v[$col], true, true) : $v[$col];
					if(strpos($key, 'pages') === 0 and is_string($v[$col]) and $v[$col] != strip_tags($v[$col])) {
						// NB In this case $v[$col] is json so we need to fix quotes in img src
						if($type != 'current') {
							$v[$col] = $migrationPage->replaceImgSrcPath($v[$col], $type, true);
						} else {
							$v[$col] = str_replace('\"', "'", $v[$col]);
						}
					}
				}
				if($draft) {
					$this->updateDraft($draft, $keyArray, $v);
				}
				return '<td style="word-wrap: break-word">' . $v[0] . '</td><td style="word-wrap: break-word">' . $v[1] . '</td>';
			}
		}

		$out = '';
		$deep += 1;
		foreach($value as $k => $v) {
			$out .= '</tr><tr><td>' . str_repeat('>&nbsp;', $deep) . $k . '</td>';
			if(is_array($v)) {
				$out .= $this->formatCompare($migrationPage, $pageType, $v, $key, $newOld, $draft, $keyArray, $deep);
			}
			//bd($out, 'out for ' . $k);
		}
		return $out;
	}

	/**
	 * Return the maximum depth of a multi-dimensional array
	 * Currently just used in the module, but seems to be a useful function
	 *
	 * @param array $array
	 * @return int
	 *
	 */
	public function array_depth(array $array) {
		$max_depth = 1;
		foreach($array as $value) {
			if(is_array($value)) {
				$depth = $this->array_depth($value) + 1;

				if($depth > $max_depth) {
					$max_depth = $depth;
				}
			}
		}
		return $max_depth;
	}

	/**
	 *
	 * Create migration items from database comparison
	 *
	 * @param $draft
	 * @param $keyArray
	 * @param $v
	 * @throws WireException
	 *
	 */
	protected function updateDraft($draft, $keyArray, $v) {
		if(strpos($v[0], '!!NO_OBJECT!!')) {
			$action = 'new';
		} else if(strpos($v[1], '!!NO_OBJECT!!')) {
			$action = 'removed';
		} else {
			$action = 'changed';
		}
		$this->addDbMigrateItem($draft, $keyArray, $action);
	}

	/**
	 *
	 * Add specified migration item to draft migration
	 *
	 * @param $draft
	 * @param $action
	 * @param $keyArray
	 * @return DbMigrationPage
	 * @throws WireException
	 *
	 */
	protected function addDbMigrateItem($draft, $keyArray, $action) {
		/* @var $draft DbMigrationPage */
		$name = $keyArray[2];
		$type = $keyArray[0];
		$repeaters = ['dbMigrateItem' => [[
			'dbMigrateName' => $name,
			'dbMigrateAction' => $action,
			'dbMigrateType' => $type
		]]];
		$draft->setAndSaveRepeaters($repeaters, $draft, $this->first);  // remove other repeaters on first setting...
		$this->first = false;  // ...but not thereafter
		return $draft;
	}


	/**
	 * Config inputfields
	 *
	 * @param InputfieldWrapper $inputfields
	 * @throws WireException
	 *
	 */
	public function getModuleConfigInputfields(InputfieldWrapper $inputfields) {
		$modules = $this->wire()->modules;
		// JqueryWireTabs is loaded in init()

		// Load custom CSS and JS
		$config = $this->wire()->config;
		$info = $this->getModuleInfo();
		$version = $info['version'];
		$config->styles->add($config->urls->$this . "{$this}.css?v=$version");
		$config->scripts->add($config->urls->$this . "{$this}.js?v=$version");

		$moduleUrl = $this->wire()->urls->siteModules . 'ProcessDbMigrate/';
		if(file_exists($this->modulePath . "help.html")) {
			$help = file_get_contents($this->modulePath . "help.html");
			$help = str_replace('src="help', 'src="' . $moduleUrl . 'help/', $help);
			$help = '<span style="color:blue">' . $help . '</span>';
		} else if(file_exists($this->modulePath . "help.md")) {
			$help = file_get_contents($this->modulePath . "help.md");
			$help = str_replace('](help/', '](' . $moduleUrl . 'help/', $help);
			$help = $modules->TextformatterMarkdownExtra->markdown($help);
			$help = '<span style="color:blue">' . $help . '</span>';
		} else {
			$help = '';
		}

		// Wrapper to hold the tabs
		/** @var InputfieldWrapper $tabs_container */
		$tabs_container = $this->wire(new InputfieldWrapper());
		// All newly-created objects that are derived from Wire SHOULD have their dependencies injected. In order to do this, pass the new object through the wire() method.
		$tabs_container->id = 'mct-tabs-container';
		$inputfields->add($tabs_container);

		// Tab 1
		/** @var InputfieldWrapper $tab1 */
		$tab1 = $this->wire(new InputfieldWrapper());
		$tab1->attr('title', 'Settings');
		$tab1->attr('class', 'WireTab');
		$tab1->columnWidth = 100;
		$tabs_container->add($tab1);

		/* @var InputfieldText $f */
		$f = $modules->InputfieldText;
		$f_name = 'database_name';
		$f->name = $f_name;
		$f->label = $this->_('Database name');
		$f->description = $this->_('Optional name for this database - to tag migrations exported from it.');
		$f->notes = $this->_('If used, any migrations exported from this database will be tagged with its name. 
			Imported migrations tagged with this name will be treated as exportable, not installable (see help for more detail).');
		$f->columnWidth = 75;
		$f->value = $this->$f_name;
		$tab1->add($f);

		/* @var InputfieldCheckbox $f */
		$f = $modules->InputfieldCheckbox;
		$f_name = 'show_name';
		$f->name = $f_name;
		$f->label = $this->_('Show database name in notice');
		$f->description = $this->_('Display the database name as a notice in every admin page.');
		$f->notes = $this->_('Only displayed if user is superuser or has admin-dbMigrate permission');
		$f->columnWidth = 25;
		$f->value = $this->$f_name;
		$f->checked = ($f->value == 1) ? 'checked' : '';
		$tab1->add($f);

		/* @var InputfieldTextarea $f */
		$f = $modules->InputfieldTextarea;
		$f_name = 'exclude_fieldtypes';
		$f->name = $f_name;
		$f->label = $this->_('Exclude Field types');
		$f->description = $this->_('Field types that are selected here will be excluded from page migrations. Enter the field type as text, (comma-separated for multiple types).');
		$f->notes = $this->_('DbMigrateRuntime, RuntimeMarkup and RuntimeOnly field types are excluded anyway as they do not hold data.'); //RuntimeMarkup and RuntimeOnly are names
		$f->columnWidth = 33;
		$f->value = $this->$f_name;
		$tab1->add($f);

		/* @var InputfieldTextarea $f */
		$f = $modules->InputfieldTextarea;
		$f_name = 'exclude_fieldnames';
		$f->name = $f_name;
		$f->label = $this->_('Exclude Fields');
		$f->description = $this->_('Fields that are selected here will be excluded from page migrations. Enter the field name as text, (comma-separated for multiple field names).');
		$f->notes = $this->_('For example fields which do not hold data.');
		$f->columnWidth = 33;
		$f->value = $this->$f_name;
		$tab1->add($f);

		/* @var InputfieldTextarea $f */
		$f = $modules->InputfieldTextarea;
		$f_name = 'exclude_attributes';
		$f->name = $f_name;
		$f->label = $this->_('Exclude Attributes');
		$f->description = $this->_('Attributes that are selected here will be excluded from template and field migrations. Enter the attribute name as text, (comma-separated for multiple attributes).');
		$f->notes = $this->_("For example differences in CKEditor plugins that you don't want reported.");
		$f->columnWidth = 33;
		$f->value = $this->$f_name;
		$tab1->add($f);

		/* @var InputfieldCheckbox $f */
		$f = $modules->InputfieldCheckbox;
		$f_name = 'auto_install';
		$f->name = $f_name;
		$f->label = $this->_('Auto-install bootstrap?');
		$f->description = $this->_('Automatically install bootstrap on upgrade or other change.');
		$f->notes = $this->_('Leave checked in normal use. Deselect it if you wish to preview any bootstrap changes before installing them.');
		$f->columnWidth = 50;
		$f->value = $this->$f_name;
		$f->checked = ($f->value == 1) ? 'checked' : '';
		$tab1->add($f);

		/* @var InputfieldCheckbox $f */
		$f = $modules->InputfieldCheckbox;
		$f_name = 'prevent_overlap';
		$f->name = $f_name;
		$f->label = $this->_('Prevent conflicting page saves?');
		$f->description = $this->_('Any changes to pages in a target database which are within the scope of unlocked installable migrations will be prevented.');
		$f->notes = $this->_('Leave checked in normal use. Deselect if it causes problems - but be aware that this may affect the ability to uninstall the related migration(s). 
		Note that saving of field and template changes is not prevented - avoid changing fields and templates in the target database, particularly if they are in the scope of an unlocked migration.');
		$f->columnWidth = 50;
		$f->value = $this->$f_name;
		$f->checked = ($f->value == 1) ? 'checked' : '';
		$tab1->add($f);

		// Tab 2
		/** @var InputfieldWrapper $tab2 */
		$tab2 = $this->wire(new InputfieldWrapper());
		$tab2->attr('title', 'Help');
		$tab2->attr('class', 'WireTab');
		$tabs_container->add($tab2);

		/* @var InputfieldMarkup $f */
		$f = $modules->InputfieldMarkup;
		$f_name = 'help';
		$f->name = $f_name;
		$f->label = $this->_('Help');
		$f->description = $this->_('');
		$f->notes = $this->_('');
		$f->columnWidth = 100;
		$f->value = $help;
//        $f->collapsed = Inputfield::collapsedYes;
		$tab2->add($f);

	}

	/*********************
	 ******* HOOKS********
	 ********************/

	/**
	 * Before save actions:
	 * Disallow saving of pages which are inside the scope of unlocked installable migrations
	 *
	 * @param HookEvent $event
	 * @throws WireException
	 *
	 */
	protected function beforeSave(HookEvent $event) {
		/*
		 * This hook only operates on pages saved outside the installPages method
		 */
		if(!$this->wire()->session->get('dbMigrate_installPages')) {
			$p = $event->arguments(0);
			$conflict = false;
			foreach($this->migrations->find("template={$this->migrationTemplate}") as $migration) {
				/* @var $migration DbMigrationPage */
				if($migration->meta('locked')) continue;
				if(!$migration->meta('installable')) continue;
				if(!$this->prevent_overlap) continue; //config setting
				$migrationList = $migration->listItems();
				$migrationNames = $migration->extractElements($migrationList, 'name');
				$migrationOldNames = array_filter($migration->extractElements($migrationList, 'oldName'));
				$intersect = in_array($p->path, $migrationNames);
				$intersectOld = in_array($p->path, $migrationOldNames);
				if($intersect or $intersectOld) {
					$conflict = true;
					break;
				}
			}
			if($conflict) {
				$this->error("$p->name - " . $this->_("This page is within the scope of an unlocked (currently installable) migration and cannot be changed unless the migration is amended or locked."));
				$event->replace = true;
				$event->return;
			}
		}
	}

	/**
	 * Inputfield::exportConfigData causes problems with page reference fields, so bypass it
	 * ToDo Need a better solution for this
	 *
	 * @param HookEvent $event
	 *
	 */
	public function beforeExportConfigData(HookEvent $event) {
		if($this->wire()->session->get('skipExportConfigData')) {   // session var is set in DbMigrationPage::getExportStructureData()
			$data = $event->arguments(0);
			$event->replace = true;
			$event->return = $data;
		}
	}

}
